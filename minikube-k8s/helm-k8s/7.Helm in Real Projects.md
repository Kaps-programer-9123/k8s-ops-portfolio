## **Step 7: Helm in Real Projects (CI/CD & Production) ğŸ”„**

Now that you know **how Helm works (basics + customization + advanced)**, letâ€™s see how itâ€™s used in real-world setups with **CI/CD pipelines, GitOps tools, and automated rollouts**.

---

### **7.1 The Story: â€œMeet Kapil â€“ The DevOps Engineerâ€** ğŸ‘¨â€ğŸ’»

Kapil is a DevOps engineer at a mid-sized fintech company.
His team manages **20+ microservices** running on **Kubernetes (EKS)**.
Before Helm, every deployment meant:

* Writing multiple **YAML files (Deployment, Service, ConfigMaps, Secrets)**
* Manually editing versions and configs
* Handling **different environments (dev/stage/prod)**

It was **slow, repetitive, and error-prone**.

Then Kapil introduced **Helm** â€” and it changed the entire release process.

---

### **7.2 Helm Repository & Versioning ğŸ“¦**

Kapil set up a **private Helm repository** using **ChartMuseum** hosted on AWS S3.

```bash
helm repo add fintech-internal s3://helm-charts-fintech
helm repo update
```

For each microservice (e.g., `payments-api`), they followed **semantic versioning**:

* Chart version (`Chart.yaml`): `1.3.2`
* Application version (`appVersion`): `2.0.5`

```yaml
# Chart.yaml
apiVersion: v2
name: payments-api
version: 1.3.2
appVersion: "2.0.5"
```

Each release was packaged and pushed:

```bash
helm package ./payments-api
helm push payments-api-1.3.2.tgz oci://s3.amazonaws.com/helm-charts-fintech
```

---

### **7.3 CI/CD Pipeline with Helm âš™ï¸**

Kapil used **Azure DevOps** to automate deployments.

Pipeline stages:

1. **Lint & Template Validation**

```bash
helm lint ./charts/payments-api
helm template ./charts/payments-api
```

2. **Package & Push to Helm Repo**

```bash
helm package ./charts/payments-api
helm push payments-api-1.3.2.tgz oci://s3.amazonaws.com/helm-charts-fintech
```

3. **Deploy to Kubernetes (Dev â†’ Stage â†’ Prod)**

```bash
helm upgrade --install payments-api fintech-internal/payments-api \
  -f values-prod.yaml
```

Each environment had **separate values files**:

* `values-dev.yaml`
* `values-stage.yaml`
* `values-prod.yaml`

---

### **7.4 GitOps with Helm (ArgoCD / FluxCD) ğŸ”„**

Later, Kapil moved to **GitOps using ArgoCD**.

* Manual `helm upgrade` was no longer needed.
* A **Git repository defined the desired state**:

  * Helm chart version
  * Values files
* ArgoCD **automatically synced the cluster**.

Example ArgoCD Application:

```yaml
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: payments-api
spec:
  source:
    repoURL: 'https://helm-charts-fintech.s3.amazonaws.com'
    chart: payments-api
    targetRevision: 1.3.2
    helm:
      values: |
        replicaCount: 4
  destination:
    namespace: payments
    server: https://kubernetes.default.svc
```

---

### **7.5 Rollback & Disaster Recovery ğŸ›¡**

One day, a **buggy release (v2.0.6)** broke payments.
Kapil calmly rolled back:

```bash
helm history payments-api
# Shows revisions: 1, 2, 3 (failed), 4

helm rollback payments-api 2
```

Within seconds, **the system was restored**.

---

### **7.6 Production Best Practices ğŸŒŸ**

Kapilâ€™s checklist:

* Pin chart versions (`1.3.2`, not `latest`)
* Sign & verify charts:

```bash
helm sign payments-api-1.3.2.tgz --key devops-team-key
helm verify payments-api-1.3.2.tgz
```

* Use **sealed secrets or Vault** for credentials
* Automate image scanning (e.g., Trivy)
* Keep **separate namespaces per environment**

---

### **7.7 Example: Azure DevOps Helm Deployment Snippet**

```yaml
stages:
- stage: Deploy
  jobs:
  - job: DeployWithHelm
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - checkout: self
    - script: |
        echo "Adding internal repo"
        helm repo add fintech-internal s3://helm-charts-fintech
        helm repo update
        echo "Deploying to Prod"
        helm upgrade --install payments-api fintech-internal/payments-api \
          -f charts/payments-api/values-prod.yaml
      displayName: 'Helm Upgrade Prod'
```

---

### **7.8 What You Learned in Step 7 âœ…**

* How **you (Kapil)** can integrate Helm into CI/CD
* Versioning and private repo best practices
* GitOps with ArgoCD/FluxCD
* Rollback strategies
* Production hardening techniques

---

### **Next Step â†’ Step 8: Debugging & Troubleshooting Helm ğŸ›**

* Run `--dry-run` before a risky deployment
* Debugging failed hooks or hanging releases
* Inspect rendered manifests (`helm template`)

---