## **Step 8 & 9: Debugging, Troubleshooting & Securing Helm in Production ðŸ›ðŸ”**

By now, **Kapil** has mastered Helm for deployments and CI/CD. But real-world Kubernetes isnâ€™t always smooth â€” things break, secrets leak, rollouts fail.

This step will teach you:

* How to **debug and troubleshoot Helm releases**
* Common failure scenarios and recovery tricks
* **Security hardening for Helm & RBAC**
* Production-grade Helm best practices

---

### **8.1 Common Helm Failure Scenarios & Fixes**

#### **Scenario 1: Release Failed During Install**

Kapil tries to install a chart:

```bash
helm install payments-api fintech-internal/payments-api
```

and gets:

```
Error: INSTALLATION FAILED: rendered manifests contain a resource that already exists
```

**Cause:** A resource (like Service) already exists in the namespace.

**Fix:**

```bash
helm install payments-api fintech-internal/payments-api --replace
```

Or clean up manually:

```bash
kubectl delete svc payments-api
helm install payments-api fintech-internal/payments-api
```

---

#### **Scenario 2: Helm Upgrade Hangs**

```bash
helm upgrade payments-api fintech-internal/payments-api
```

Helm hangs at:

```
Waiting for deployment "payments-api" rollout to finish...
```

**Cause:** Readiness probes failing â†’ deployment stuck.

**Debug:**

```bash
kubectl describe pod payments-api-xxxxx
kubectl logs payments-api-xxxxx
```

**Fix:** Update `values-prod.yaml` with correct config, rollback if needed:

```bash
helm rollback payments-api 3
```

---

#### **Scenario 3: Failed Hooks (Pre/Post Install)**

Helm hooks can block the release if they fail.

**Debug hooks:**

```bash
helm get hooks payments-api
helm uninstall payments-api --keep-history
```

**Tip:** Always test hooks locally before pushing to production.

---

#### **Scenario 4: Corrupted Helm State**

Sometimes a Helm release is stuck in `FAILED` status.

**Check history:**

```bash
helm history payments-api
```

**Delete release but keep history:**

```bash
helm uninstall payments-api --keep-history
```

**Reinstall cleanly:**

```bash
helm install payments-api fintech-internal/payments-api
```

---

### **8.2 Debugging Tools & Commands**

* **Dry run without applying:**

```bash
helm install payments-api ./chart --dry-run --debug
```

* **Render YAML without installing:**

```bash
helm template payments-api ./chart > rendered.yaml
kubectl apply -f rendered.yaml
```

* **Inspect a release:**

```bash
helm get all payments-api
```

* **Test a chart before using it:**

```bash
helm lint ./chart
```

---

### **9.1 Securing Helm: RBAC & Access Control**

By default, Helm interacts with Kubernetes using a Service Account. Kapil ensures **least privilege** with RBAC.

Example: Helm-only namespace access

```yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: helm-user
  namespace: payments
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: helm-role
  namespace: payments
rules:
- apiGroups: ["", "apps", "extensions"]
  resources: ["deployments", "services", "pods", "configmaps", "secrets"]
  verbs: ["get", "list", "create", "update", "delete", "patch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: helm-binding
  namespace: payments
subjects:
- kind: ServiceAccount
  name: helm-user
  namespace: payments
roleRef:
  kind: Role
  name: helm-role
  apiGroup: rbac.authorization.k8s.io
```

Kapil runs Helm as:

```bash
helm upgrade --install payments-api ./chart \
  --namespace payments \
  --service-account helm-user
```

---

### **9.2 Secure Secrets Management**

Helm can deploy Secrets, but theyâ€™re base64-encoded (not encrypted). Kapil uses:

* **Sealed Secrets (Bitnami)**: Encrypts secrets before committing to Git

```bash
kubeseal --format=yaml < secret.yaml > sealedsecret.yaml
```

* **HashiCorp Vault or SOPS** for secret injection

---

### **9.3 Chart Signing & Verification**

Kapil signs charts to prevent tampering:

```bash
helm package ./payments-api --sign --key devops-team-key --keyring ./keyring.gpg
helm verify payments-api-1.4.0.tgz
```

---

### **9.4 Helm Best Practices (Kapilâ€™s Checklist)**

* Always run `helm lint` and `--dry-run` before production
* Pin versions (`chartVersion: 1.4.0`, `appVersion: 2.1.1`)
* Store values in Git (not secrets!)
* Use **`helm dependency update`** to manage subcharts
* Prefer **OCI-based Helm repos** (more secure than HTTP)

---

### **9.5 Quick Recovery Strategy**

When production is on fire:

1. Run `helm history <release>`
2. Pick a stable revision
3. Rollback:

```bash
helm rollback payments-api 5
```

4. Debug what went wrong, patch, and re-release

---

### **What You Learned in Step 8 & 9 âœ…**

* Real-world Helm failure modes & their fixes
* Debugging tools (`--dry-run`, `helm template`, `helm get all`)
* RBAC for Helm service accounts
* Secure secrets handling (Sealed Secrets, Vault)
* Chart signing & integrity checks
* Production-ready Helm best practices


### **Next Step â†’ Helm at Scale (Step 10)**

---

[Back to - Helm in Real Projects](https://github.com/Kaps-programer-9123/k8s-ops-portfolio/blob/main/minikube-k8s/helm-k8s/7.Helm_in_Real_Projects.md)

[Read Step 10 â€” Helm at Scale](https://github.com/Kaps-programer-9123/k8s-ops-portfolio/blob/main/minikube-k8s/helm-k8s/10.Helm_at_Scale.md)
